0) Create a repo for this project on my github account and sync the current state of the files to that repo.

1) Modify Select-Object to respect the following:
 ## Property Expansion (`-ExpandProperty`)

When using `-ExpandProperty <String>` within `Select-Object`, follow these strict behavioral rules:

* Type Transformation: If the property is an array, output each value individually. If it is an object, expand its properties for every input object. The output type must match the expanded property's type.
* Error Handling: If the specified property does not exist, return an error.
* Collision Constraints: Property expansion cannot replace existing properties. If the expanded object or the selected object contains a property with the same name then rename the original property by prepending the string "O" for Original.  e.g. Name become OName.
* Side Effects: If `-Property` is also specified, attempt to add those selected properties as members to every outputted object.

2) Update format-table and format-list to support calculated formatting properties.  Calculated formatting properties are hash table syntax with the following elements
    -   Name/Label - optional
    -   Expression
    -   FormatString - optional
    -   Width - optional
    -   Alignment - optional
e.g. format-table -property name, @{name="TEST"; expression ="handles"; width = 15}


3) Update every location that uses an expression to use powershell object notation.  The current object is referred to by 
the variable name $_ or $this and properties are accessed with . notation e.g. $_.Name, $this.Name.length
The following buildin functions should be invoked not as functions but as method calls on the object or it's properites:
Built-in Functions:
  upper(s), lower(s)    Convert string case
  len(s)                String or array length
  trim(s)               Remove whitespace
  substring(s, start, len)  Extract substring
  round(n), floor(n), ceil(n)  Numeric rounding
  abs(n), sqrt(n)       Numeric functions

e.g  len(name) => $_.Name.len()   
e.g. floor(handles) => $this.Handles.floor()

4) Implement foreach-object with aliases "foreach" and "%"
  The `ForEach-Object` cmdlet performs an operation on each item in a collection of input objects. The input objects can be piped to the cmdlet or specified using the InputObject parameter.
  
    -Begin {ScriptBlock} alias '-b'
        Specifies a script block that runs before this cmdlet processes any input objects. This script block is only run once for the entire pipeline. For more information about the `begin`
        block, see about_Functions (about/about_functions.md#piping-objects-to-functions).

      -Process {ScriptBlock} alias '-p'
        Specifies the operation that's performed on each input object. This script block is run for every object in the pipeline. For more information about the `process` block, see
        about_Functions (about/about_functions.md#piping-objects-to-functions).

  -End {ScriptBlock} alias '-e'
        Specifies a script block that runs after this cmdlet processes all input objects. This script block is only run once for the entire pipeline. For more information about the `end`
        block, see about_Functions (about/about_functions.md#piping-objects-to-functions).

        When you provide multiple script blocks to the Process parameter, the first script block is always mapped to the `begin` block. If there are only two script blocks, the second block
        is mapped to the `process` block. If there are three or more script blocks, first script block is always mapped to the `begin` block, the last block is mapped to the `end` block, and

   -Script block . You can use a script block to specify the operation. Within the script block,   use the `$_` and '$this' variables to represent the current object.

    The script block is the value of
    the Process parameter. 
    ScriptBlock can contain any PowerShell script.

   -MemberName <System.String>
    Specifies the name of the member property to get or the member method to call. The members must be instance members, not static members.

    Wildcard characters are permitted, but work only if the resulting string resolves to a unique value. For example, if you run `Get-Process | foreach -MemberName *Name`, the wildcard
    pattern matches more than one member causing the command to fail.
 
    
    ------------ Example 1: Divide integers in an array ------------
    
    30000, 56798, 12432 | ForEach-Object -Process {$_/1024}
    
    29.296875
    55.466796875
    12.140625
    
    
    -- Example 2: Get the length of all the files in a directory --
    
    Get-ChildItem $PSHOME |
      ForEach-Object -Process {if (!$_.PSIsContainer) {$_.Name; $_.Length / 1024; " " }}
    
    If the object isn't a directory, the script block gets the name of the file, divides the value of its Length property by 1024, and adds a space (" ") to separate it from the next entry. 
    The cmdlet uses the PSIsContainer property to determine whether an object is a directory.
    ----- Example 3: Operate on the most recent System events -----
    
    Get-EventLog -LogName System -Newest 1000 |
        ForEach-Object -Begin {Get-Date} -Process {
            COMMAND -FilePath Events.txt -Append -InputObject $_.Message
        } -End {Get-Date}
    
    `Get-EventLog` gets the 1000 most recent events from the System event log and pipes them to the `ForEach-Object` cmdlet. The Begin parameter displays the current date and time. Next, the 
    Process parameter uses the `Out-File` cmdlet to create a text file that's named events.txt and stores the message property of each of the events in that file. Last, the End parameter is 
    used to display the date and time after all the processing has completed.
    -------- Example 4: Change the value of a Registry key --------
    
    Get-ItemProperty -Path HKCU:\Network\* |
      ForEach-Object {
        COMMAND -Path $_.PSPath -Name RemotePath -Value $_.RemotePath.ToUpper()
      }
    
    You can use this format to change the form or content of a registry entry value.
    
    Each subkey in the Network key represents a mapped network drive that reconnects at sign on. The RemotePath entry contains the UNC path of the connected drive. For example, if you map 
    the `E:` drive to `\Server\Share`, an E subkey is created in `HKCU:\Network` with the RemotePath registry value set to `\Server\Share`.
    
    The command uses the `Get-ItemProperty` cmdlet to get all the subkeys of the Network key and the `Set-ItemProperty` cmdlet to change the value of the RemotePath registry entry in each 
    key. In the `Set-ItemProperty` command, the path is the value of the PSPath property of the registry key. This is a property of the Microsoft .NET Framework object that represents the 
    registry key, not a registry entry. The command uses the ToUpper() method of the RemotePath value, which is a string REG_SZ .
    
    Because `Set-ItemProperty` is changing the property of each key, the `ForEach-Object` cmdlet is required to access the property.
    --------- Example 5: Use the $null automatic variable ---------
    
    1, 2, $null, 4 | ForEach-Object {"Hello"}
    
    Hello
    Hello
    Hello
    Hello
    
    Because PowerShell treats `$null` as an explicit placeholder, the `ForEach-Object` cmdlet generates a value for `$null` as it does for other objects piped to it.
    ---------------- Example 6: Get property values ----------------
    
    Get-Module -ListAvailable | ForEach-Object -MemberName Path
    Get-Module -ListAvailable | foreach Path
    
    The second command is equivalent to the first. It uses the `Foreach` alias of the `ForEach-Object` cmdlet and omits the name of the MemberName parameter, which is optional.
    
    The `ForEach-Object` cmdlet is useful for getting property values, because it gets the value without changing the type, unlike the Format cmdlets or the `Select-Object` cmdlet, which 
    change the property value type.
    ------ Example 7: Split module names into component names ------
    
    "Microsoft.PowerShell.Core", "Microsoft.PowerShell.Host" |
        ForEach-Object {$_.Split(".")}
    "Microsoft.PowerShell.Core", "Microsoft.PowerShell.Host" |
        ForEach-Object -MemberName Split -ArgumentList "."
    "Microsoft.PowerShell.Core", "Microsoft.PowerShell.Host" |
        foreach Split "."
    
    Microsoft
    PowerShell
    Core
    Microsoft
    PowerShell
    Host
    
    The first command uses the traditional syntax, which includes a script block and the current object operator `$_`. It uses the dot syntax to specify the method and parentheses to enclose 
    the delimiter argument.
    
    The second command uses the MemberName parameter to specify the Split method and the ArgumentList parameter to identify the dot (`.`) as the split delimiter.
    
    The third command uses the `foreach` alias of the `ForEach-Object` cmdlet and omits the names of the MemberName and ArgumentList parameters, which are optional.
    ---- Example 8: Using ForEach-Object with two script blocks ----
    
    1..2 | ForEach-Object { 'begin' } { 'process' }
    
    begin
    process
    process
    
    
    Example 9: Using ForEach-Object with more than two script blocks
    
    1..2 | ForEach-Object { 'begin' } { 'process A' }  { 'process B' } { 'end' }
    
    begin
    process A
    process B
    process A
    process B
    end
    
    > [!NOTE] > The first script block is always mapped to the `begin` block, the last block is mapped to the > `end` block, and the two middle blocks are mapped to the `process` block.
    Example 10: Run multiple script blocks for each pipeline item
    
    1..2 | ForEach-Object -Begin $null -Process { 'one' }, { 'two' }, { 'three' } -End $null
    
    one
    two
    three
    one
    two
    three
    
    
   5) Modify jps.exe command line parameters to use PowerShell syntax instead of Linux syntax.  e.g. use "-" instead of "--" 

   6) Update jps.exe command line parameters to include a -Begin, a -Process and a -End parameter each of which takes a ScriptBlock.
   The Begin scriptblock is run at the begining.
   Then the input object are piped to the -Process scriptblock
   Then the End scriptblock is run at then end.
   e.g.
   1,2,3,4,5 | jps.exe -begin {$count = 0} {$count++} {"Total number of ojects is $count"}



